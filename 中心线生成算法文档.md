# TrafficGuideLine 中心线生成算法文档

## 概述

本文档详细分析了 TrafficGuideLine.ms 脚本中的中心线生成算法和中心骨骼计算算法。该脚本用于基于两条样条线生成V字形导流线标记，主要包含两种计算模式：偏移量模式和固定骨骼模式。

## 核心算法

### 1. 中心路径计算算法 (calculateCenterPath)

**功能**: 计算两条样条线之间的中心路径

```maxscript
fn calculateCenterPath spline1 spline2 =
(
    local centerPoints = #()  -- 存储中心点的数组
    local spline1Length = curveLength spline1 1  -- 获取样条线1的长度
    local spline2Length = curveLength spline2 1  -- 获取样条线2的长度
    local maxLength = amax spline1Length spline2Length  -- 取较长的长度作为参考
    
    if maxLength > 0 then
    (
        -- 沿路径采样点，计算中心线
        local sampleCount = 50  -- 采样点数量，控制中心线的精度
        for i = 0 to sampleCount do
        (
            local param = i as float / sampleCount as float  -- 计算参数化位置 [0,1]
            
            -- 在两条样条线上获取对应点
            local pos1 = lengthInterp spline1 1 param  -- 样条线1上的对应点
            local pos2 = lengthInterp spline2 1 param  -- 样条线2上的对应点
            
            -- 计算中心点（两点的中点）
            local centerPos = (pos1 + pos2) / 2.0
            append centerPoints centerPos  -- 添加到中心点数组
        )
    )
    
    return centerPoints  -- 返回中心路径点集合
)
```

**算法原理**:
1. 通过参数化采样的方式，在两条样条线上获取对应的点
2. 计算每对对应点的中点，形成中心路径
3. 采样点数量为50个，确保足够的精度

### 2. 样条线起始点重合分析算法 (analyzeSplineIntersection)

**功能**: 检测两条样条线的起始点是否重合，并计算封闭线段信息

```maxscript
fn analyzeSplineIntersection spline1 spline2 =
(
    local intersectionTolerance = 50.0  -- 相交判定容差（系统单位）
    
    -- 获取两条样条线的起始点
    local spline1Start = lengthInterp spline1 1 0.0  -- 样条线1的起始点
    local spline2Start = lengthInterp spline2 1 0.0  -- 样条线2的起始点
    
    -- 检查起始点是否重合
    local startIntersect = (distance spline1Start spline2Start) < intersectionTolerance
    
    -- 返回结果：#(起始点重合状态, 封闭线段数据)
    local startClosureLine = undefined
    
    -- 只有在起始点未重合时才创建封闭线段
    if not startIntersect then
        startClosureLine = #(spline1Start, spline2Start)
    
    return #(startIntersect, startClosureLine)
)
```

**算法原理**:
1. 获取两条样条线的起始点
2. 通过距离判断起始点是否重合（容差50单位）
3. 仅在起始点未重合时创建封闭线段信息
4. 简化逻辑：不再检测尾点，专注于起始点连接

### 3. V字形位置计算算法 (calculateVShapePositions)

**功能**: 计算导流线V字形的位置分布（偏移量控制版本）

```maxscript
fn calculateVShapePositions spline1 spline2 vSpacing direction centerOffset =
(
    local result = #()
    local centerPoints = calculateCenterPath spline1 spline2  -- 获取中心路径
    
    -- 分析样条线相交情况
    local intersectionInfo = analyzeSplineIntersection spline1 spline2
    local startIntersect = intersectionInfo[1]  -- 首点是否相交
    local endIntersect = intersectionInfo[2]    -- 尾点是否相交
    
    if centerPoints.count > 1 then
    (
        -- 计算中心路径的总长度
        local totalLength = 0
        for i = 2 to centerPoints.count do
        (
            totalLength += distance centerPoints[i-1] centerPoints[i]
        )
        
        if totalLength > centerOffset then
        (
            -- 计算需要避开的封闭区域长度
            local closureBuffer = vSpacing * 0.5  -- 封闭区域缓冲距离
            
            -- 只有在对应位置有封闭线段时才设置缓冲区域
            local startOffset = if startIntersect then 0 else closureBuffer  -- 首点未相交时避让
            local endOffset = if endIntersect then 0 else closureBuffer      -- 尾点未相交时避让
            
            -- 有效的V字形生成区域（从首点算起）
            local validStartDist = startOffset
            local validEndDist = totalLength - endOffset
            local validLength = validEndDist - validStartDist
            
            if validLength > vSpacing then
            (
                -- 直接使用用户设置的间距值
                local actualSpacing = vSpacing
                
                -- 计算V字形数量（在有效区域内）
                local numVShapes = (validLength / actualSpacing) as integer
                
                -- 生成V字形位置（从有效起点开始）
                for vIdx = 1 to numVShapes do
                (
                    local targetDist = validStartDist + (vIdx - 1) * actualSpacing
                    
                    -- 确保在有效区域内
                    if targetDist >= validStartDist and targetDist <= validEndDist then
                    (
                        local currentDist = 0
                        
                        -- 在中心路径上找到对应位置
                        for i = 2 to centerPoints.count do
                        (
                            local segmentLength = distance centerPoints[i-1] centerPoints[i]
                            
                            if currentDist + segmentLength >= targetDist then
                            (
                                -- 在这个线段上插值
                                local segmentParam = (targetDist - currentDist) / segmentLength
                                local vPos = centerPoints[i-1] + (centerPoints[i] - centerPoints[i-1]) * segmentParam
                                
                                -- 计算V字形方向
                                local vDir = normalize (centerPoints[i] - centerPoints[i-1])
                                if direction < 0 then vDir = -vDir
                                
                                -- 计算路径参数以获取实际边界点
                                local pathParam = targetDist / totalLength
                                local leftBoundary = lengthInterp spline1 1 pathParam
                                local rightBoundary = lengthInterp spline2 1 pathParam
                                
                                -- 计算基于偏移量的动态角度（偏移方向向后）
                                local dynamicAngle = calculateAngleFromOffset vPos vDir leftBoundary rightBoundary centerOffset
                                
                                append result #(vPos, vDir, leftBoundary, rightBoundary, dynamicAngle)
                                exit
                            )
                            
                            currentDist += segmentLength
                        )
                    )
                )
            )
        )
    )
    
    return result
)
```

**偏移量计算函数**:
 
 ```maxscript
 fn calculateAngleFromOffset centerPos centerDir leftBoundary rightBoundary offsetDistance =
 (
     -- 计算目标点位置（从中心点沿方向向后偏移，按照箭头指示方向）
     local targetPoint = centerPos - (normalize centerDir) * offsetDistance
     
     -- 计算从目标点到左右边界的向量
     local toLeft = normalize (leftBoundary - targetPoint)
     local toRight = normalize (rightBoundary - targetPoint)
     
     -- 计算两个向量之间的夹角
     local dotProduct = dot toLeft toRight
     dotProduct = amax -1.0 (amin 1.0 dotProduct)  -- 限制在有效范围内
     local angleRad = acos dotProduct
     local angleDeg = radToDeg angleRad
     
     return angleDeg
 )
```

**算法原理**:
1. 基于中心路径计算总长度
2. 考虑封闭区域，计算有效生成区域
3. 按照指定间距在有效区域内分布V字形位置
4. 为每个位置计算方向向量和边界点
5. 根据偏移量动态计算每个V字形的开合角度

## 中心骨骼计算算法

### 1. 偏移量控制模式骨骼计算

**功能**: 基于偏移量动态调整V字形的开合角度，实现几何重心固定控制

```maxscript
-- 偏移量控制模式：固定几何重心，动态计算角度
local centerPos = vPos  -- V字形的几何重心位置（红色十字标记）
local pathDirection = vDir  -- 路径方向向量
local dynamicAngle = calculateAngleFromOffset centerPos pathDirection leftBoundary rightBoundary centerOffset

-- 创建V字形，几何重心固定在centerPos
local vShape = createStandardVShape centerPos pathDirection leftBoundary rightBoundary dynamicAngle lineThickness
```

**算法原理**:
1. **偏移量控制**: 用户通过指定从中心点沿中心线向后的偏移距离来控制V字形开合
2. **动态角度计算**: 根据偏移距离和边界约束动态计算最适合的开合角度
3. **几何重心固定**: V字形的几何重心始终保持在红色十字标记位置
4. **偏移方向修正**: 按照箭头指示方向，偏移量增大时目标点向后移动，V字形变窄
5. **数学模型**: 
   - 目标点计算：`targetPoint = centerPos - normalize(centerDir) * offsetDistance`
   - 角度计算：`angle = arccos(dot(leftVector, rightVector))`
   - 边界约束：左右端点严格约束在对应边界线上
   - 实时响应：偏移距离变化时实时更新V字形形状

### 2. 几何重心控制V字形创建算法

**功能**: 创建几何重心固定的V字形，确保重心位置稳定

```maxscript
fn createStandardVShape centerPos pathDirection leftBoundary rightBoundary vAngle lineThickness =
(
    -- 计算V字形的几何参数
    local halfAngle = vAngle / 2.0
    local halfAngleRad = degToRad halfAngle
    
    -- 计算边界距离和臂长
    local boundaryDistance = distance leftBoundary rightBoundary
    local armLength = boundaryDistance / (2.0 * sin halfAngleRad)
    
    -- 计算几何重心偏移量
    local longitudinalOffset = armLength * cos halfAngleRad / 3.0
    
    -- 计算顶点位置（从几何重心向后偏移）
    local vertex = centerPos - (normalize pathDirection) * longitudinalOffset
    
    -- 创建V字形几何体
    local vShape = createVShapeGeometry vertex leftBoundary rightBoundary lineThickness
    
    return vShape
)
```

**算法原理**:
1. **几何重心固定**: V字形的几何重心始终保持在指定的centerPos位置
2. **边界约束**: 左右端点严格约束在对应的边界线上
3. **角度精确控制**: V字形的开合角度精确等于指定的vAngle
4. **数学模型**: 
   - 几何重心计算：`重心 = (顶点 + 左端点 + 右端点) / 3`
   - 臂长计算：`armLength = boundaryDistance / (2 * sin(halfAngle))`
   - 顶点偏移：`vertex = centerPos - longitudinalOffset * pathDirection`
   - 解析求解：使用数学解析解确保计算精度和效率

### 3. V字形角度计算算法

**功能**: 计算V字形的开合角度

```maxscript
fn calculateVShapeAngle leftBoundary rightBoundary centerBottom =
(
    -- 计算从中心底部到左右边界的向量
    local leftVector = normalize (leftBoundary - centerBottom)
    local rightVector = normalize (rightBoundary - centerBottom)
    
    -- 计算两个向量之间的夹角（弧度）
    local dotProduct = dot leftVector rightVector
    -- 限制点积值在有效范围内，避免数值误差
    dotProduct = amax -1.0 (amin 1.0 dotProduct)
    local angleRadians = acos dotProduct
    
    -- 转换为度数
    local angleDegrees = radToDeg angleRadians
    
    return angleDegrees
)
```

**算法原理**:
1. 计算从中心点到左右边界的向量
2. 使用向量点积计算夹角
3. 转换为度数返回

## 算法特点

### 优势
1. **自适应性**: 能够根据道路宽度动态调整V字形形状
2. **精确性**: 通过参数化采样确保中心线计算精度
3. **灵活性**: 采用固定中心模型，开合角度固定但边长动态适应
4. **完整性**: 考虑了封闭区域的处理

### 应用场景
1. **道路标线设计**: 用于生成符合标准的导流线
2. **交通工程**: 辅助交通标线的自动化设计
3. **3D建模**: 在三维环境中快速生成道路标记

## 参数说明

| 参数名 | 类型 | 说明 | 默认值 |
|--------|------|------|--------|
| centerOffset | Float | 中心偏移量(mm) | 200 |
| vSpacing | Float | V字形间距(mm) | 1200 |
| lineThickness | Float | 线条厚度(mm) | 100 |
| standardVLength | Float | 标准臂长(mm) | 300 |
| standardVAngle | Float | 标准角度(度) | 60 |
| sampleCount | Integer | 采样点数量 | 50 |
| intersectionTolerance | Float | 相交容差 | 50 |

## 总结

该算法通过精确的数学计算和几何分析，实现了基于两条样条线的中心线生成和V字形导流线的自动布置。算法考虑了实际应用中的各种情况，包括样条线相交、封闭区域处理、角度限制等，具有很强的实用性和可靠性。